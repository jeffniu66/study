---
typora-root-url: ../study
typora-copy-images-to: ./gc_img
---

# GC(Garbage Collection)

## go gc

<font color=red>STW(stop the world)</font>

| 版本 | 发布时间 | GC算法                                                       | STW时间       | 重大更新                              |
| ---- | :------- | ------------------------------------------------------------ | ------------- | :------------------------------------ |
| V1.1 | 2013.5   | STW                                                          | 可能秒级别    |                                       |
| V1.3 | 2014.6   | Mark和Sweep分离. Mark STW, Sweep并发                         | 百ms级别      |                                       |
| V1.4 | 2014.12  | runtime代码基本都由C和少量汇编改为Go和少量汇编, 包括GC部分, 以此实现了准确式GC,减少了堆大小, 同时对指针的写入引入了write barrier, 为1.5铺垫 | 百ms级别      |                                       |
| V1.5 | 2015.8   | 三色标记法, 并发Mark, 并发Sweep. 非分代, 非移动, 并发的收集器 | 10ms-40ms级别 | 重要更新版本,生产上GC基本不会成为问题 |
| V1.6 | 2016.2   | 1.5中一些与并发GC不协调的地方更改. 集中式的GC协调协程, 改为状态机实现 | 5-20ms        |                                       |
| V1.7 | 2016.8   | GC时栈收缩改为并发, span中对象分配状态由freelist改为bitmap   | 1-3ms左右     |                                       |
| V1.8 | 2017.2   | hybird write barrier, 消除了stw中的重新扫描栈                | sub ms        | Golang GC进入Sub ms时代               |

### go v1.3 之前的标记-清除(mark and sweep)

#### 流程

1.暂停程序业务逻辑，找出不可达的对象，和可达对象

2.开始标记，程序找出它所有可达的对象，并做上标记

3.标记完了之后，然后开始清除未标记的对象

4.停止暂停，让程序继续跑。然后循环这个过程，直到process程序声明周期结束

优化方法

将第4步和第3步换位置，缩短STW的范围

#### 缺点

* 需要STW，让程序暂停，会出现卡顿

* 标记需要扫描整个heap

* 清除数据会产生heap碎片

![image-20210307093851564](/gc_img/image-20210307093851564.png)

![image-20210307095233936](/gc_img/image-20210307095233936.png)

### go v1.5 三色标记法

黑白灰

<font color=red>三色标记算法是对标记阶段的改进</font>

程序起初创建，全部标记为白色，将所有对象放入白色集合中。

#### 流程

1.就是只要是新创建的对象，默认的颜色都是标记为“白色”

![image-20210307104057625](/gc_img/image-20210307104057625.png)

2.每次GC回收开始，然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合

![image-20210307104131889](/gc_img/image-20210307104131889.png)

3.遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合

![image-20210307104804055](/gc_img/image-20210307104804055.png)

4.重复第3步，直达灰色中无任何对象

![image-20210307105000482](/gc_img/image-20210307105000482.png)

![image-20210307105038782](/gc_img/image-20210307105038782.png)

5.回收所有的白色标记表的对象，也就是回收垃圾

![image-20210307105220614](/gc_img/image-20210307105220614.png)

<font color=red>三色标记无STW保护的问题</font>

三色标记最不希望发生的事

* <font color=gree>条件1：一个白色对象被黑色对象引用（白色被挂在黑色下）</font>

* <font color=gree>条件2：灰色对象与它之间的可达关系的白色对象遭到破坏（灰色同时丢了该白色）</font>

两个条件同时满足，就会出现对象丢失现象！

![image-20210307121644926](/gc_img/image-20210307121644926.png)

最简单的方式就是STW

STW的过程有明显的资源浪费，对所有的用户程序都有很大影响

<font color=red>如何能保证对象不丢失的情况尽可能的提高GC效率，减少STW时间呢？</font>

#### 强弱三色不变色

##### 强三色不变色

强制性不允许黑色对象引用白色对象，破坏条件1

![image-20210307124149970](/gc_img/image-20210307124149970.png)

##### 弱三色不变色

黑色对象可以引用白色对象，白色对象存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象，破坏条件2

![image-20210307124753297](/gc_img/image-20210307124753297.png)

#### 屏障机制

![image-20210307125709423](/gc_img/image-20210307125709423.png)

![image-20210307125823506](/gc_img/image-20210307125823506.png)

##### 插入写屏障

<font color=red>对象被引用时 触发的机制</font>

![image-20210307131326132](/gc_img/image-20210307131326132.png)

不在栈上使用，栈空间小；堆空间大

###### 流程

![image-20210307142755856](/gc_img/image-20210307142755856.png)

![image-20210307143047655](/gc_img/image-20210307143047655.png)

![image-20210307143148914](/gc_img/image-20210307143148914.png)

在准备回收白色前，重新遍历扫描一次栈空间。此时加STW暂停保护栈，防止外界干扰（有新的白色被黑色添加）

![image-20210307143641253](/gc_img/image-20210307143641253.png)

![image-20210307143814973](/gc_img/image-20210307143814973.png)

###### 不足

结束时需要STW来重新扫描栈，大约需要10~100ms

<font color=gree>CMS和G1都使用了三色标记法</font>

##### 删除写屏障

<font color=red>对象被删除时 触发的机制</font>

![image-20210307144647548](/gc_img/image-20210307144647548.png)

###### 流程

![image-20210307153345009](/gc_img/image-20210307153345009.png)

![image-20210307153408724](/gc_img/image-20210307153408724.png)

![image-20210307153435189](/gc_img/image-20210307153435189.png)

![image-20210307153459916](/gc_img/image-20210307153459916.png)

###### 不足

回收精度低

一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

### go v1.8 三色标记法+混合写屏障操作流程

![image-20210307155017976](/gc_img/image-20210307155017976.png)

#### 流程

1.gc刚刚开始，默认都为白色

![image-20210308074709679](/gc_img/image-20210308074709679.png)

2.三色标记法，优先扫描全部栈对象，将可达对象均标记为黑色

![image-20210308074927211](/gc_img/image-20210308074927211.png)



<font color=gree>go gc的代码主要集中在mgc.go的gcStart()函数中</font>

## java gc





![3C1BBC9F-C044-4CAA-A329-022DE7AB987F](/gc_img/3C1BBC9F-C044-4CAA-A329-022DE7AB987F.png)



### 引用计数法

1960年提出的

#### 原理

<font color=gree>假设有一个对象A，任何一个对象对A引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收。</font>

#### 优点

* 实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。

* 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报outofmemory 错误。

* 区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。

#### 缺点

* 每次对象被引用时，都需要去更新计数器，有一点时间开销。

* 浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。

* <font color=red>无法解决循环引用问题。（最大的缺点）</font>

### 标记-清除

<font color=red>***能标记的都是可用的，未标记的都是垃圾***</font>

#### 原理

<font color=gree>Mark: 从heap的根节点开始遍历整个heap，标记还“活着”的Object</font>

<font color=gree>Sweep: 删除heap中的Object</font>

![image-20210308212621126](/gc_img/image-20210308212621126.png)

#### 优点

* 标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。

#### 缺点

* 效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。

* 通过标记清除算法清理出来的内存，<font color=red>碎片化较为严重</font>，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。

### 标记压缩（整理）法

#### 原理

<font color=gree>标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。</font>

![image-20210307171915778](/gc_img/image-20210307171915778.png)

#### 优缺点

* 优缺点同标记清除算法，<font color=red>解决了标记清除算法的碎片化的问题</font>，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有一定的影响。

### 复制算法

#### 原理

<font color=gree>复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。</font>

![image-20210307172608725](/gc_img/image-20210307172608725.png)

#### 优点

- 在垃圾对象多的情况下，效率较高 。
- 清理后，内存无碎片。

#### 缺点

- 在垃圾对象少的情况下，不适用，如：老年代内存。
- 分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低

### 分代算法

<font color=red>根据回收对象的特点进行选择，在jvm中，新生代用复制算法，老年代用标记-清除或标记-整理算法。</font>

每一种算法都有自己的优点也有缺点，谁都不能替代谁，所以根据垃圾回收对象的特点进行选择，才是明智的选择。

## 内存分配

本来想顺便讲一下内存分配差异，发现太多内容了，大概讲一下，可以后期再细讲。。

### java

#### 运行时内存

![image-20210307203339140](/gc_img/image-20210307203339140.png)

#### 分代的堆内存

![74116B7D-8220-404E-B1C0-E4CCE2F3001F](/gc_img/74116B7D-8220-404E-B1C0-E4CCE2F3001F.png)

![9F9EEE5F-6256-4F8C-88CC-3D5CABE6E5AD](/gc_img/9F9EEE5F-6256-4F8C-88CC-3D5CABE6E5AD.png)



### go

#### 运行时内存

Go的运行时内存就是操作系统分配给进程空间的堆、栈内存，在堆内存的使用上不像JVM分代管理，而是采用<font color=red>分层级</font>的内存管理模式。

#### 分层级的堆内存

Go的堆内存直接采用了TCMalloc库的内存管理模型。TCMalloc库是Google开发的现代内存分配器，其基本特征是内存分层级、对抗内存碎片以及快速分配等。Go语言根据自身需求对TCMalloc做了很多优化，但仍保留了其基本架构。

Go的内存分配器是分层级的，由mcache/mcentral/mheap 三个组件构成。因此整个堆内存结构可以看成是三层级的内存模型，其结构如下图所示：

![image-20210307204024259](/gc_img/image-20210307204024259.png)

```go
· 缓存组件mcache与工作线程（goroutine）绑定，是goroutine私有的内存空间。在mcache中为对象分配内存时，无需竞争，性能很高。

· 中间组件mcentral 只负责一种规格（size class）的内存块，为mcache缓存组件提供备用的特定规格的可用空间。mcache的内存扩容请求会被分散到不同的mcentral 组件上，以减小共享内存的竞争锁粒度。

· 堆组件mheap负责管理用户程序的所有可用堆内存空间以及为大对象直接分配内存。它为上层组件提供扩容支持。当空间不足时，mheap组件向操作系统申请内存。
```























