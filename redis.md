---
typora-root-url: ../study
---

# 面试题

## 缓存

### 缓存穿透

**当查询redis中没有的数据时，会直接查询数据库，同时数据库也没有数据，这种情况大量出现或恶意攻击时，这种现象为“缓存穿透”。**

<font color="red">解决方案：</font>

1.在接口访问层对用户做校验，如接口传参、登录状态、n秒内访问接口的次数；

2.利用布隆过滤器，可以先将数据库中数据的key存储在布隆过滤器的位数组中，每次客户端先访问redis：

* 如果redis内不存在该数据，则通过布隆过滤器判断数据是否在底层数据库内；
* 如果布隆过滤器返回该key在底层库内不存在，则直接返回null给客户端即可，避免了查询底层数据库的动作；
* 如果布隆过滤器返回该key极有可能存在，那么将查询底层数据库。

```
布隆过滤器有误判率，虽然不能完全避免数据穿透的现象，但已经可以将99.99%的穿透查询给屏蔽在Redis层了，极大的降低了底层数据库的压力，减少了资源浪费。
```

### 布隆过滤器

有一个改造加强版：布谷鸟过滤器

本质是一个二进制数组，不存在为0，存在为1；通过n次hash计算数组下标，把数组值改为1

![image-20210206102457200](/interview_img/image-20210206102457200.png)

会存在误判的情况，如果设置的误判率越小，但是计算的时间就越长。

过滤器的内容都要往内存中放。

<font color="red">布隆算法：通过一定的错误率来换取空间</font>

弊端：删除数据

### 缓存击穿

**当数据库中有数据而缓存内没有数据**，当热点数据key从缓存内存失效时，大量访问同时请求这个数据，就会直接查数据库，导致数据库压力骤增，这种现象为**“缓存击穿”**

<font color="red">解决方案：</font>

1.延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口；

2.利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至redis内，避免其他大量请求同时穿透redis访问底层数据库；

![image-20201107002917107](/Users/liuzhidong/Documents/md/study/redis_images/image-20201107002917107.png)

在使用互斥锁的时候需要**避免出现死锁或者锁过期**的情况：

- 使用前面文章介绍过的lua脚本或事务将获取锁和设置过期时间作为一个原子性操作，以避免出现某个客户端获取锁之后宕机导致的锁不被释放造成死锁现象；
- 另起一个线程监控获取锁的线程的查询状态，快到锁过期时间时还没查询结束则延长锁的过期时间，避免多次查询多次锁过期造成计算资源的浪费；

### 缓存雪崩

**缓存雪崩是缓存击穿的“大面积”版，是指redis中大量的key几乎同时过期，然后大量并发查询直接打到底层数据库上，此时数据库负载压力骤增，称为“缓存雪崩”**

<font color="red">解决方案：</font>

1.在可接受的范围内随机设置key的过期时间，分散key的过期时间，以防止大量的key在同一时期过期；

2.缓存预热，在项目刚启动后，可以人为访问一遍；